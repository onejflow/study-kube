# ConfigMap, Secret 

Dev와 Production 환경에서 설정값만 다르게 컨테이너 이미지를 각각 관리해야하면 비효율적임. 그래서 환경에 따라 변하는 값들을 외부에서 결정할 수 있도록 도와주는게 ConfigMap과 Secret임

ConfigMap은 '보여줘도 되는 설정값(예: DB 주소)'을 담고, Secret은 '숨겨야 하는 비밀값(예: DB 비밀번호)'을 담는 오브젝트.


| 특징     | ConfigMap (컨피그맵)        | Secret (시크릿)                         |
| ------ | ----------------------- | ------------------------------------ |
| 목적     | 일반적인 환경 설정 분리           | 민감한 보안 데이터 보호                        |
| 데이터 예시 | DB URL, 포트, 설정 파일(conf) | 패스워드, API Key, 인증서                   |
| 저장 방식  | 평문 (Plain Text)         | Base64 인코딩 (옵션에 따라 암호화 저장)           |
| 용량 제한  | 제한 없음 (etcd 용량 내)       | 1MB (etcd 부하 방지) |

## ConfigMap

ConfigMap은 기밀이 아닌 데이터를 key-value로 저장
- 컨테이너 이미지 안에 설정 파일을 하드코딩하지 않고, 외부에서 주입할 수 있게함
- 이를 통해 개발(Dev), 테스트(Test), 운영(Prod) 환경마다 이미지를 새로 만들 필요 없이 ConfigMap만 교체하여 배포


사용 시기:

- 애플리케이션의 로깅 레벨 설정 (예: LOG_LEVEL=DEBUG)
- 데이터베이스 호스트 주소 또는 포트 번호 (예: DB_HOST=10.0.0.1)
- Nginx나 Redis 같은 애플리케이션의 전체 설정 파일 (nginx.conf, redis.conf)

사용 방법:

- 파드(Pod)의 **환경 변수(Environment Variable)**로 주입.
- 컨테이너 내부의 특정 경로에 **파일(Volume)**로 마운트

## Secret (시크릿)
Secret은 암호, 토큰, 키 등 민감한 정보를 저장하기 위한 오브젝트.  ConfigMap과 사용 방식은 거의 동일하지만, 보안을 위해 데이터가 평문이 아닌 Base64로 인코딩되어 저장되며, 쿠버네티스 설정에 따라 디스크가 아닌 메모리(tmpfs)에만 저장되거나 etcd 저장 시 암호화될 수 있다. 
- Base64 인코딩은 보안적인 요소가 아니라 단순히 시크릿의 밸류를 만들어야 된다는 규칙이 있어서 Pod에 들어갈 때 디코딩됨

사용 시기:
- 데이터베이스 비밀번호 (예: DB_PASSWORD=xg9#2a!)
- API 인증 토큰 또는 OAuth 키
- HTTPS 통신을 위한 TLS/SSL 인증서 및 개인키
- 프라이빗 도커 레지스트리(Private Registry) 접근 자격 증명

주의사항:

기본적으로 Base64로 인코딩만 되어 있을 뿐 암호화된 것은 아니므로, 접근 제어(RBAC)를 통해 아무나 볼 수 없도록 관리해야 합

# ConfigMap 과 Secret 주입 방식 

| 구분                            | 1. Env (Literal / Single)  (특정 Key만 쏙 뽑아 쓰기) | 2. Env (File / Bulk)  (통째로 환경변수로 붓기)                         | 3. Volume Mount (File)  (파일로 만들어 넣기)                         |
| ----------------------------- | -------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ConfigMap / Secret 입장(데이터 정의) | Key-Value 데이터User: dev                       | Key-Value 데이터User: devSSH: false                             | Key = 파일명Value = 파일 내용nginx.conf : server { ... }            |
| Pod 입장(YAML 설정)               | valueFrom 사용가져올 Key를 정확히 지정(key: User)       | envFrom 사용Key를 지정하지 않고 통째로 참조(configMapRef: name)            | volumes & volumeMounts특정 경로(폴더)에 마운트(mountPath: /etc/config) |
| 결과물(컨테이너 내부)                  | 환경변수 생성MY_ID = dev(변수명 내가 지정 가능)             | 환경변수 여러 개 생성User = devSSH = false(원본 Key가 변수명이 됨)            | 파일 생성/etc/config/nginx.conf(파일을 열면 내용이 보임)                   |
| 사용 케이스(언제 쓰나?)                | 특정 설정값 몇 개만 필요할 때예: DB_HOST, PORT            | 설정값이 매우 많을 때예: .env 파일 통째로 로딩,Spring Boot application.yml 대체 | 설정 파일 자체가 필요할 때예: nginx.conf, tls.crt(인증서),settings.json     |
| 리소스 갱신 시(값 바꾸면 반영되나?)         | ❌ 반영 안 됨Pod를 지웠다 다시 만들어야 함(Restart 필요)       | ❌ 반영 안 됨Pod를 지웠다 다시 만들어야 함(Restart 필요)                       | ✅ 자동 반영됨ConfigMap 수정 시 잠시 후파일 내용이 바뀜 (약 1분 내외)               |

## ENV (Literal)



```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: cm-dev
data:
  SSH: 'false'
  User: dev
```

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: sec-dev
data:
  Key: MTIzNA==
```

- secret은 key에 base64형태로 인코딩이 되어야함

Pod 생성, 내부로 들어가 env를 확인하면 주입된걸 확인할 수 있음
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-1
spec:
  containers:
  - name: container
    image: kubetm/init
    envFrom:
    - configMapRef:
        name: cm-dev
    - secretRef:
        name: sec-dev
```

## ENV (File)

```shell
echo "Content" >> file-c.txt
kubectl create configmap cm-file --from-file=./file-c.txt

echo "Content" >> file-s.txt
kubectl create secret generic sec-file --from-file=./file-s.txt
```
- 명령어로 Secret를 생성할 때는 내용을 자동으로 Base64 해주기 때문에, 별도로 "Content"를 Base64 해줄 필요 없음 

- 이렇게 명령어를 날리면, 쿠버네티스의 etcd(데이터 저장소) 안에 텍스트 데이터 형태로 저장.

컨피그맵을 확인해보면 
```json
{
	"file-c.txt": "Content
		"
}
```
이렇게 저장이 되어 있음


```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-file
spec:
  containers:
  - name: container
    image: kubetm/init
    env:
    - name: file-c # 컨테이너 안에서는 'file-c'라는 환경 변수 이름으로 사용
      valueFrom:
        configMapKeyRef:
          name: cm-file
          key: file-c.txt # cm-file이라는 ConfigMap 안에 'file-c.txt'라는 이름(Key)을 가진 데이터 사용
    - name: file-s
      valueFrom:
        secretKeyRef:
          name: sec-file
          key: file-s.txt
```

## Volume Mount (file)


이전 단계에서 마스터 노드에 쳤던 명령어대로 etcd라는곳에 데이터가 있기에 적용

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-mount
spec:
  containers:
  - name: container
    image: kubetm/init
    volumeMounts:
    - name: file-volume
      mountPath: /mount # 결과: /mount/file-c.txt 파일이 생김
  volumes: # etcd(DB)에 있는 ConfigMap 데이터를 가져와서
  - name: file-volume   # 'file-volume'이라는 이름표를 붙여 Pod가 쓸 수 있는 덩어리(Volume)로 만듭니다.
    configMap:
      name: cm-file #etcd에서 'cm-file'이라는 이름의 ConfigMap을 찾음
```

